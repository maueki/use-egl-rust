extern crate nix;
extern crate libloading;

use libloading::Library;
use nix::libc::{c_long, c_void, int32_t, uint64_t};
use std::ffi::{CStr, CString};
use std::ptr;

// for bindings.rs (generated by gl-generator)
pub type khronos_utime_nanoseconds_t = khronos_uint64_t;
pub type khronos_uint64_t = uint64_t;
pub type khronos_ssize_t = c_long;
pub type EGLint = int32_t;
pub type EGLNativeDisplayType = NativeDisplayType;
pub type EGLNativePixmapType = NativePixmapType;
pub type EGLNativeWindowType = NativeWindowType;
pub type NativeDisplayType = *const c_void;
pub type NativePixmapType = *const c_void;
pub type NativeWindowType = *const c_void;

mod egl {
    use super::*;
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}


fn main() {

    let lib = Library::new("libEGL.so.1").unwrap();
    let egl = egl::Egl::load_with(|sym| {
        let name = CString::new(sym).unwrap();
        unsafe {
            let symbol = lib.get::<*mut c_void>(name.as_bytes());
            match symbol {
                Ok(x) => *x as *const _,
                Err(_) => ptr::null(),
            }
        }
    });

    unsafe {
        let extensions = egl.QueryString(egl::NO_DISPLAY, egl::EXTENSIONS as i32);

        if (!extensions.is_null()) {
            let p = CStr::from_ptr(extensions);
            let list = String::from_utf8(p.to_bytes().to_vec()).unwrap_or_else(|_| String::new());
            println!("EGL querystring: {}", list);
        }
    }
}

